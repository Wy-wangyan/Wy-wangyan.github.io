---
layout: post
title: 一笔以太坊交易的生命周期
tags: [Ethereum]
image: '/images/posts/ethereum_network.png'
---


交易(Transaction)是以太坊(Ethereum)区块链或者任何一种区块链网络最重要的部分。当你和以太坊交互的时候，你就是在执行交易并且在更新它的状态。最近我在学习以太坊相关的开发的时候就对于执行交易背后发生的活动比较好奇，于是看了一些东西总结一下。
在这篇博客中我们会讨论如下内容：

- 一笔以太坊交易从你的浏览器/控制台发送到以太坊网络然后回到你的浏览器/控制台的一个端到端的传播过程。
- 理解当你使用一个类似于Metamask(我现在自己部署合约测试就在用这个扩展)或者Myetherwallet(没接触过)的插件的时候一个交易是如何工作的。
- 当你不信任任何的插件的时候你该如何执行你的交易
  
![ethereum_network](/images/posts/ethereum_network.png)

##  以太坊交易的端到端概述
我们以如下的合约作为一个例子，用它来贯穿整个介绍交易如何执行并且永久存储到区块链上的流程。这是一个简单的投票合约，这个合约里面一些候选人进行一个选举，并且任何人都可以为他们投票，当然票数会被区块链记录。

```javascript
Voting.deployed().then(function(instance) {
    instance.voteForCandidate('Nick', {gas: 140000, from: web3.eth.accounts[0]}).then(function(r) {
     console.log("Voted successfully!")
    })
    })
```
假设现在你有一个以太坊的客户端(比如Geth)在你的电脑本地运行，并且连接到一个网络(可能是开发者测试网络或者是以太坊的主网络)。你拥有合约地址和相关的ABI来执行交易。
如果设计过DAPP，应该对上面的代码比较熟悉。有个叫Voting的合约并且已经被部署到区块链上了。我们实例化这个合约并且执行这个叫voteForCandidate的函数，参数包含了候选者的名字，这笔交易的gas limit和执行这笔交易的账户。这个函数是用来给候选者投票并且将会被记录到区块链上。接下来我们将讨论在执行这个javascript函数时所发生的所有活动。

### 1.原始交易目标的构建
`voteForCandidate`函数调用首先会被转化成一个原始的交易(rawTxn)。而这里就用到Web3js库来构造这个交易目标。

```javascript
txnCount = web3.eth.getTransactionCount(web3.eth.accounts[0])
var rawTxn = {
    nonce: web3.toHex(txnCount),
    gasPrice: web3.toHex(100000000000),
    gasLimit: web3.toHex(140000),
    to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b',
    value: web3.toHex(0),
    data: '0xcc9ab24952616d6100000000000000000000000000000000000000000000000000000000'
};
```
接下来让我们理解这个交易中包含的所有字段的含义以及它们是如何被设置的。
**nonce**:每个以太坊的账户都有一个字段叫nonce来追踪这个账户所执行过的交易的总数量。有新的交易的话，这个nonce就会增长，并且这也会让网络知道需要被执行的交易的顺序。

**gasPrice**：你愿意为这笔交易所支付的每单位的gas的价格，如果你正在主网上执行你的交易，你就应该为你的交易设置一个合理的gas price来保证它的成功执行。现在Gas的价格是用GWei来衡量的，一般在0.1到100+范围。

**gasLimit**：你愿意为你这笔交易所支付的最多的gas。这个值的目的是为了在有些情况下，比如你的交易中有一个无穷的循环，你账户里的钱不会全花光，这种情况下剩余的gas会退回到你的账户当中去。

**to**：这是你调用这个函数所定向的地址，在我们所举的例子中，地址(0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b)是投票合约的地址。

**value**：你想要发送的总共的以太。当我们执行`voteForCandidate`的时候，我们并没有发送以太的需求，所以这里是0。当你执行一个交易并且想发送以太给另外一个人或者一个合约的时候，这里就需要设置了。

**data**：让我们看一下这个字段是如何生成的。(这里我一般通过在线的智能合约编译器remix直接编译后获得)

你首先从从ABI获取这个函数的签名，再生成它的哈希。
```javascript
> web3.sha3('voteForCandidate(bytes32)')

'0xcc9ab267dda32b80892b2ae9e21b782dbf5562ef3e8919fc17cab72aa7db9d59'
```
你首先取出这个哈希序列的前4个字节也就是0xcc9ab267，然后将变量‘Nick’转变成32字节然后你就得到52616d6100000000000000000000000000000000000000000000000000000000。然后合并这两部分就获得了data字段。

### 2.为交易签名
我们之前用账户web3.eth.accounts[0]执行了交易。以太坊网络需要知道你真的拥有该账户，并且确定别人无法代表你来执行这个交易。我们就通过用个人的私钥对交易签名来向网络证明你就是对应这个账户。签名后的交易是这样的

```javascript
const privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')

const txn = new EthereumTx(rawTxn)
txn.sign(privateKey)
const serializedTxn = txn.serialize()
```
### 3.本地验证交易有效
被签名后的交易被提交到你的本地以太坊节点，你本地的节点将会验证这个交易来确保它是被这个账户地址所签名的。

### 4.交易广播到网络中
签名的交易通过你的geth节点广播到peer节点，并且peer也会向自己的peers继续传播。一旦交易被广播到网络中，你本地节点同样会输出一个交易的id来追踪你的这笔交易的状态。这个交易的id一半就是签名后的交易对象的哈希。
```javascript
transactionId = sha3(serializedTxn)
```

如果你在公共的以太坊网络执行你的交易，最好是在[etherscan.io](https://etherscan.io)追踪你的交易的状态。它有前端的webapp连接一些节点，当他们的节点收到你的交易的时候，你就可以在网站上看到你的待处理的交易。
还有一点就是并不是所有的节点都会接受你交易。一些节点可能被设置只接受一个被设定的最小gas价格的交易。

### 5.矿工节点接受交易
以太坊网络的矿工节点和非矿工根节点是混合的。矿工简单来说就是将你的交易信息打包到区块当中的人。在你的交易被添加到区块之前，矿工会维护一个交易信息的池子，他们会开始对这些交易进行评估验证。矿工会根据gas price排序并且存储所有的交易，如果gas price的价格越高，那么这笔交易就越可能会被包含到下一个区块当中。不过这是一般的矿工节点配置，这样做的好处就是会有更高的收益。但是一个矿工也可以根据他自己的意愿来对交易进行排序，比如说他值帮助那些低gas的交易来挖矿。


![txn](/images/posts/txn.png)


从上面的图片，我们看到voteForCandidate交易是在矿池的最底端，只有当上面有更高的gas费的交易被挖矿并且记录到区块中之后，矿工才会来考虑我们的交易。矿工的池子只能装得下有限数量的交易。比如说现在有一个比较热门的ICO销售正在进行，或者一个受欢迎的DAPP。人们都将他们的交易附上一大笔gas price希望矿工能够最先选择他们的交易。如果高gas价格的交易充满了整个池子，那么你的低gas price的交易就可能直接被忽略了。这种情况下我们可能需要重新广播这个交易。或者你重新提交你的交易并且附上一笔更高的gas price，但你用同样的nonce。这样当你的交易被矿工接受的时候，更高gas price的交易会覆盖掉你的老的交易。如果nonce值不同，这就会被认为是一笔不同的交易。

### 6.矿工节点找到有效的区块并广播到网络
矿工最终选择我们的交易并且将它和其他的交易一起打包到区块当中。矿工只能够打包这么多交易是因为以太坊有他的一个区块gas limit，也就是所有交易的gas limit不能超过区块的gas limit.
一旦矿工选择了一些交易并且将它们包含到区块当中，交易全都会被验证并且放到一个准区块当中，然后就开始进行PoW共识。一个矿工节点最终解决PoW问题，也就是我们小标题说的找到有效的区块，并且把区块打包上链，然后矿工节点就会广播这个有效的区块到其他节点当中，然后所有其他的节点，包括你自己的节点就都会收到。

### 7.本地节点接收/同步新区块
最终你的节点会接收新区块并且下载区块链的一份本地复制。一旦接受新区块，本地节点就会执行区块上所有的交易。
如果你用truffle来执行你的交易，truffle会不断地统计区块链来确认，当它看到交易被确认之后，它就会执行代码来输出控制台日志。

## 使用Metamask
如果你安装的Metamask浏览器插件，你就可以通过浏览器来管理你的账户。密钥都只存储在你浏览器里，所以你是唯一能够使用你的账户和私钥的人。当你在你浏览器当中执行一笔交易的时候，这个插件会将函数调用转变成一个原始的交易并且用你的私钥来对交易签名。Metamask在他们自己的节点上运行，这样你就甚至都不用运行你的以太坊节点了。



